{% extends "layout.html" %}

{% block head %}
{{ super() }}

<script src="https://cdn.jsdelivr.net/npm/vega@5.3.4"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-lite@3.1.0"></script>
<script src="https://cdn.jsdelivr.net/npm/vega-embed@4.0.0"></script>

<script src="{{ url_for('static', filename='js/constant.js') }}" /></script>
<script src="{{ url_for('static', filename='js/chart.js') }}" /></script>
<script src="{{ url_for('static', filename='js/query.js') }}" /></script>

<style>
  .container {
    padding: 2px;
    text-align: center;
  }
  .container table {
    margin: auto;
    width: auto;
    border-spacing: 0px;
  }
  .container th, td {
    text-align: left;
    padding-left: 10px;
    padding-right: 10px;
  }
  .query-td {
    text-align: left;
  }
  .color-box {
    margin: auto;
    width: 20px;
    height: 20px;
  }
</style>
{% endblock %}

{% block header %}{% endblock %}

{% block content %}
<div class="container" id="options"></div>
<div class="container">
  <table id="search-table"><tbody></tbody></table>
</div>
<div class="container">
  <div id="chart"></div>
</div>

<script>
  let params = (new URL(document.location)).searchParams;
  let data = JSON.parse(decodeURIComponent(params.get('data')));
  let width = params.get('width');
  let height = params.get('height');
  let chart_options = data.options;

  function renderText(lines) {
    // TODO: XSS attack here
    lines.forEach(line => {
      let html = `<tr name='${line.color}'>
        <td><div class="color-box" style="background-color: ${line.color};"></div></td>
        <td class="query-td">${line.query.query}</td>
      </tr>`;
      $('#search-table tbody').append(html);
    });
    $('#options').html(`Showing results for the following from <b>${chart_options.start_date}</b> to <b>${chart_options.end_date}</b> aggregated by <b>${chart_options.aggregate}</b>.`);
  }

  let lines = data.queries.map(raw_query => {
    var parsed;
    try {
      parsed_query = new SearchableQuery(
        raw_query.text, chart_options.count, false);
    } catch (e) {
      alertAndThrow(e.message);
    }
    return {color: raw_query.color, query: parsed_query};
  });

  $('#shade').show();
  $('#search').prop('disabled', true);

  let search_results = {};
  function onDone() {
    new Chart(
      chart_options, search_results, {width: width, height: height}
    ).load('#chart', null);
    renderText(lines);
  };

  Promise.all(lines.map(line => {
    console.log('Executing query:', line.query);

    function onError(xhr) {
      var msg;
      try {
        msg = JSON.parse(xhr.responseText).message;
      } catch {
        msg = 'Unknown server error';
      }
      alert(`[Query failed. The chart may be incomplete.]\n\n${msg}`);
      console.log('Failed:', line, xhr);
    }

    return line.query.search(
      chart_options,
      result => search_results[line.color] = result,
      onError);
  })).then(onDone).catch(onDone);
</script>
{% endblock %}
